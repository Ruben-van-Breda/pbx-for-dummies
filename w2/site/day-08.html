<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Week 2 ‚Äî Day 8: NAT Traversal ‚Äî STUN, TURN, ICE</title>
  <link rel="stylesheet" href="./site.css" />
</head>
<body>
  <main class="lesson">
    <header>
      <nav class="nav-top">
        <a href="./index.html">‚Üê Back to Week 2</a>
        <a href="./day-09.html">Next ‚Üí</a>
      </nav>
      <h1>Day 8 ‚Äî NAT Traversal: STUN, TURN, ICE</h1>
    </header>
    <section class="content">
      <h2>Objectives</h2>
      <ul>
        <li>Understand why VoIP fails behind NAT</li>
        <li>Learn how STUN, TURN, and ICE enable media connectivity</li>
      </ul>

      <h2>Key Concepts (Explained)</h2>
      <ul>
        <li><strong>NAT problem</strong>: Private IPs are unroutable; SIP/SDP may advertise private addresses.</li>
        <li><strong>STUN</strong>: Discover public IP/port mapping.</li>
        <li><strong>TURN</strong>: Relay media via a public server when P2P fails.</li>
        <li><strong>ICE</strong>: Gather candidates (host, reflexive, relayed) and test paths.</li>
      </ul>

      <h2>Media Path Logic</h2>
      <ol>
        <li>Offer/answer exchange includes ICE candidates</li>
        <li>Connectivity checks run in parallel (STUN Binding requests)</li>
        <li>Best working candidate pair is selected; others pruned</li>
      </ol>

      <h2>Hands-on (15‚Äì20 min)</h2>
      <ol>
        <li>Diagram host/reflexive/relayed candidates</li>
        <li>Test WebRTC on <a href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/" target="_blank" rel="noopener noreferrer">Trickle ICE</a> and observe candidates</li>
        <li>Note why PBX/SBCs often anchor media to simplify NAT</li>
      </ol>

      <h2>Quick Check (Self-test)</h2>
      <ul>
        <li>When is TURN required?</li>
        <li>What does STUN provide that SIP alone does not?</li>
        <li>Why can symmetric NATs be problematic?</li>
      </ul>

      <h2>Common Pitfalls</h2>
      <ul>
        <li>Missing/invalid STUN or TURN servers</li>
        <li>Symmetric NAT/firewall ‚Üí expect TURN</li>
        <li>ICE disabled or no trickle ICE</li>
        <li>UDP/RTP ports blocked</li>
        <li>Wrong public IP in SDP</li>
      </ul>

      <h2>üìö Further Reading & References</h2>
      <ul>
        <li><a href="https://webrtc.org/getting-started/ice" target="_blank" rel="noopener noreferrer">ICE ‚Äî WebRTC</a></li>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity" target="_blank" rel="noopener noreferrer">STUN & TURN ‚Äî MDN</a></li>
        <li><a href="https://www.rfc-editor.org/rfc/rfc5389" target="_blank" rel="noopener noreferrer">RFC 5389 ‚Äî STUN</a></li>
        <li><a href="https://www.rfc-editor.org/rfc/rfc5766" target="_blank" rel="noopener noreferrer">RFC 5766 ‚Äî TURN</a></li>
        <li><a href="https://www.rfc-editor.org/rfc/rfc8445" target="_blank" rel="noopener noreferrer">RFC 8445 ‚Äî ICE</a></li>
        <li><a href="https://wiki.asterisk.org/wiki/display/AST/Asterisk+SIP+NAT+support" target="_blank" rel="noopener noreferrer">Asterisk & NAT</a></li>
      </ul>

      <h2>Deliverable</h2>
      <ul>
        <li>File: <code>day8_ice_candidates.png</code> or annotated Trickle ICE screenshot</li>
        <li>Notes: When TURN is needed, which candidate pair succeeded, and why</li>
        <li>Goal: Show understanding of NAT traversal and media anchoring</li>
      </ul>

      <h2 id="appendix-deep-dives">Appendix ‚Äî Deep Dives</h2>

      <h3>Deep Dive: ICE Candidate Nomination (Regular vs Aggressive)</h3>
      <p><strong>What it is and why it matters</strong>: Nomination is how the controlling agent chooses the final candidate pair. Choosing too early can lock in a sub‚Äëoptimal path; too late delays media.</p>
      <ul>
        <li>Regular nomination waits for the highest‚Äëpriority successful check and then uses USE‚ÄëCANDIDATE (recommended with trickle ICE).</li>
        <li>Aggressive nomination marks the first check with USE‚ÄëCANDIDATE; risky with trickle ICE.</li>
        <li>Exactly one side must be controlling; resolve role conflicts via tie‚Äëbreaker (RFC 8445 ¬ß6).</li>
        <li>With ICE‚ÄëLite peers, the full agent is controlling and performs nomination.</li>
        <li>References: <a href="https://www.rfc-editor.org/rfc/rfc8445" target="_blank" rel="noopener noreferrer">RFC 8445</a>, <a href="https://webrtc.org/getting-started/ice" target="_blank" rel="noopener noreferrer">WebRTC ICE Overview</a></li>
      </ul>

      <h3>Deep Dive: TURN Allocations, Permissions, and Channels</h3>
      <p><strong>What it is and why it matters</strong>: TURN relays media when P2P fails, enabling connectivity through symmetric NATs and strict firewalls.</p>
      <ul>
        <li>Allocation lifetime ~10 minutes; must refresh (RFC 5766 ¬ß7).</li>
        <li>Permissions per peer IP last 300 seconds (RFC 5766 ¬ß8).</li>
        <li>Channels bind a peer with lower overhead vs Send Indications (RFC 5766 ¬ß11).</li>
        <li>Auth uses STUN long‚Äëterm credentials with HMAC‚ÄëSHA1 integrity (RFC 5389 ¬ß9).</li>
        <li>Ports: 3478 (UDP/TCP), 5349 (TLS). Ensure egress is allowed.</li>
        <li>References: <a href="https://www.rfc-editor.org/rfc/rfc5766" target="_blank" rel="noopener noreferrer">RFC 5766</a>, <a href="https://www.rfc-editor.org/rfc/rfc5389" target="_blank" rel="noopener noreferrer">RFC 5389</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity" target="_blank" rel="noopener noreferrer">MDN</a></li>
      </ul>

      <h3>Deep Dive: ICE Lite vs ICE Full (Servers, PBXs, SBCs)</h3>
      <p><strong>What it is and why it matters</strong>: ICE‚ÄëLite simplifies servers with public IPs by not running checks, remaining interoperable with full ICE peers.</p>
      <ul>
        <li>ICE‚ÄëLite advertises only host candidates and indicates <code>ice-lite</code> in SDP.</li>
        <li>Full agent MUST be controlling when talking to ICE‚ÄëLite and performs all checks.</li>
        <li>Use on publicly reachable media relays/SBCs; prefer full ICE if behind NAT or multi‚Äëhomed.</li>
        <li>References: <a href="https://www.rfc-editor.org/rfc/rfc8445" target="_blank" rel="noopener noreferrer">RFC 8445</a>, <a href="https://webrtc.org/getting-started/ice" target="_blank" rel="noopener noreferrer">WebRTC ICE Overview</a></li>
      </ul>

      <hr />

      <div class="quiz-controls">
        <button id="start-quiz" type="button">Start Quiz</button>
      </div>
      <div id="quiz" hidden>
        <h2>‚úÖ Quiz ‚Äî Day 8 (20 Questions + Answers)</h2>
        <ol>
          <li>What problem does NAT introduce for VoIP media?
            <ul><li>Answer: Private IP/ports are not reachable; SDP may advertise unroutable addresses.</li></ul>
          </li>
          <li>What does STUN help an endpoint discover?
            <ul><li>Answer: Its public IP and port mapping.</li></ul>
          </li>
          <li>When is TURN required?
            <ul><li>Answer: When P2P connectivity fails; media must be relayed.</li></ul>
          </li>
          <li>What does ICE do during call setup?
            <ul><li>Answer: Gathers candidates and runs checks to select the best path.</li></ul>
          </li>
          <li>Name the three main ICE candidate types.
            <ul><li>Answer: Host, server-reflexive, relayed.</li></ul>
          </li>
          <li>Why can symmetric NATs be problematic for VoIP?
            <ul><li>Answer: Different mappings per destination; breaks incoming unless relayed.</li></ul>
          </li>
          <li>What is trickle ICE?
            <ul><li>Answer: Incremental candidate gathering/signaling.</li></ul>
          </li>
          <li>One-way audio though SIP succeeds ‚Äî two likely causes?
            <ul><li>Answer: RTP ports blocked or wrong public IP in SDP.</li></ul>
          </li>
          <li>Why do PBX/SBCs often anchor media?
            <ul><li>Answer: Hide/normalize endpoints and ensure routable RTP paths.</li></ul>
          </li>
          <li>What tradeoff does TURN introduce?
            <ul><li>Answer: Higher latency and relay cost vs reliability.</li></ul>
          </li>
          <li>In regular nomination, when is USE‚ÄëCANDIDATE applied?
            <ul><li>Answer: Only after the highest‚Äëpriority successful check is selected.</li></ul>
          </li>
          <li>Why is aggressive nomination risky with trickle ICE?
            <ul><li>Answer: It can nominate a sub‚Äëoptimal pair before better candidates arrive.</li></ul>
          </li>
          <li>Who performs checks when a full ICE agent talks to an ICE‚ÄëLite agent?
            <ul><li>Answer: The full ICE agent (controlling).</li></ul>
          </li>
          <li>Default TURN allocation lifetime to maintain?
            <ul><li>Answer: About 10 minutes (refresh periodically).</li></ul>
          </li>
          <li>How long do TURN permissions last if not refreshed?
            <ul><li>Answer: 300 seconds (5 minutes).</li></ul>
          </li>
          <li>What advantage do TURN channels provide?
            <ul><li>Answer: Lower overhead and better throughput once bound.</li></ul>
          </li>
          <li>Which auth mechanism does TURN use?
            <ul><li>Answer: STUN long‚Äëterm credentials with HMAC‚ÄëSHA1 integrity.</li></ul>
          </li>
          <li>Which ports are commonly used for TURN?
            <ul><li>Answer: 3478 (UDP/TCP) and 5349 (TLS).</li></ul>
          </li>
          <li>What SDP attribute signals ICE‚ÄëLite?
            <ul><li>Answer: <code>ice-lite</code>.</li></ul>
          </li>
          <li>What resolves an ICE role conflict?
            <ul><li>Answer: The tie‚Äëbreaker procedure in RFC 8445.</li></ul>
          </li>
        </ol>
      </div>

      <style>
      .quiz-modal[hidden]{display:none}
      .quiz-modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:999}
      .quiz-modal .overlay{position:absolute;inset:0;background:rgba(0,0,0,.55)}
      .quiz-modal .dialog{position:relative;background:var(--panel);border:1px solid #2a323c;border-radius:12px;max-width:640px;width:92%;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.6)}
      .quiz-modal header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .quiz-modal header h3{margin:0}
      .quiz-modal .flashcard{background:#0f1318;border:1px solid #2a323c;border-radius:10px;padding:16px;min-height:140px}
      .quiz-modal .label{color:var(--muted);font-size:.9rem;margin-bottom:6px}
      .quiz-modal .text{white-space:pre-wrap}
      .quiz-modal .note{margin-top:10px;width:100%;min-height:80px;background:#0f1318;border:1px solid #2a323c;border-radius:8px;color:var(--text);padding:8px}
      .quiz-modal footer{display:flex;justify-content:flex-end;gap:8px;margin-top:12px}
      .quiz-modal button{background:var(--card);border:1px solid #2a323c;border-radius:10px;padding:8px 12px;color:var(--text)}
      </style>

      <div id="quiz-modal" class="quiz-modal" hidden>
        <div class="overlay" data-close="1"></div>
        <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="quiz-title">
          <header>
            <h3 id="quiz-title">Day 8 ‚Äî Quiz</h3>
            <button id="quiz-close" type="button" aria-label="Close">‚úï</button>
          </header>
          <div class="flashcard">
            <div id="flashcard-label" class="label">Question</div>
            <div id="flashcard-text" class="text"></div>
          </div>
          <textarea id="quiz-note" class="note" placeholder="Optional: jot your answer..."></textarea>
          <footer>
            <button id="quiz-back" type="button">Back</button>
            <button id="quiz-next" type="button">Next</button>
          </footer>
        </div>
      </div>

      <script>
      (function(){
        var quizContainer = document.getElementById('quiz');
        var startBtn = document.getElementById('start-quiz');
        var modal = document.getElementById('quiz-modal');
        var closeBtn = document.getElementById('quiz-close');
        var nextBtn = document.getElementById('quiz-next');
        var backBtn = document.getElementById('quiz-back');
        var labelEl = document.getElementById('flashcard-label');
        var textEl = document.getElementById('flashcard-text');
        var noteEl = document.getElementById('quiz-note');

        if(!quizContainer) return;

        var qa = [];
        var items = quizContainer.querySelectorAll('ol > li');
        items.forEach(function(li){
          var q = '';
          li.childNodes.forEach(function(node){ if(node.nodeType === Node.TEXT_NODE){ q += node.textContent; } });
          q = (q||'').trim().replace(/^\d+\)\s*/, '');
          var aEl = li.querySelector('ul li');
          var a = aEl ? aEl.textContent.replace(/^Answer:\s*/,'').trim() : '';
          if(q){ qa.push({q:q, a:a}); }
        });

        var idx = 0; var showingAnswer = false; var notes = qa.map(function(){return '';});
        function render(){
          if(!qa.length) return;
          var item = qa[idx];
          if(showingAnswer){ labelEl.textContent = 'Answer'; textEl.textContent = item.a || '(No answer provided)'; }
          else { labelEl.textContent = 'Question'; textEl.textContent = item.q; }
          if(noteEl){ noteEl.value = notes[idx] || ''; }
        }
        function openModal(){ idx=0; showingAnswer=false; render(); modal.removeAttribute('hidden'); }
        function closeModal(){ if(noteEl){ notes[idx]=noteEl.value; } modal.setAttribute('hidden',''); }
        function next(){ if(!qa.length) return; if(noteEl){ notes[idx]=noteEl.value; }
          if(!showingAnswer){ showingAnswer=true; render(); } else { showingAnswer=false; idx=(idx+1)%qa.length; render(); } }
        function back(){ if(!qa.length) return; if(noteEl){ notes[idx]=noteEl.value; }
          if(showingAnswer){ showingAnswer=false; render(); } else { idx=(idx-1+qa.length)%qa.length; showingAnswer=false; render(); } }
        if(startBtn) startBtn.addEventListener('click', openModal);
        if(closeBtn) closeBtn.addEventListener('click', closeModal);
        if(nextBtn) nextBtn.addEventListener('click', next);
        if(backBtn) backBtn.addEventListener('click', back);
        modal.addEventListener('click', function(e){ if(e.target && e.target.getAttribute('data-close')) closeModal(); });
        document.addEventListener('keydown', function(e){ if(!modal.hasAttribute('hidden') && e.key==='Escape') closeModal(); });
      })();
      </script>
    </section>
  </main>
</body>
</html>
